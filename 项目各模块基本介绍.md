## knowledge_base.py

这个，主要就是判断，上传的文件，是否已经上传过了，
通过验证md5值来判断
用户传进来一个文档，读取内容，把读取到的字符串，转化为md5，然后和本地的md5库里面的md5对比，如果有一样的，就说明已经上传过了，如果没有一样的，就会把字符串存储到chroma里面，然后保存md5.
代码模块：
检查md5是否存在：check_md5(md5_str:str)传进来一个md5，用于检查。
保存md5的函数：save_ md5
把字符串转换成md5的函数：get_md5（）通过一个hashlib的库提供的方法。
在方法里就实现内容保存到chroma的功能
chroma的方法
Chroma(
	collection_name = 数据表的名字
	embedding_function =  使用的嵌入模型（这里使用的是百炼的DashScope）
	persist_directory = 数据库保存的路径
)

spliter就是对上传的文档进行切分。
RecursiveCharacterTextSplitter（
	chunk_size =      #切分的段落字数
	chunk_overlap= #每次切分重复截取的字数，防止语义被切断
	separators =       #原始段落的分割符号，比如， 。 ？ , . ? 等等
	length_function =     #切分的字数的依据，比如用len
）

uploader_by_str函数内部实现get_md5,check_md5，save_md5，并保存到数据库,同时设定了元数据metadata。

## app_file_uploader.py
实现页面化的形式来完成文档的上传工作
st.file_uploader(
	"上传txt文件“
	type = ”txt“
	accept_multiple_files =  #是否支持上传多文件True/False
)


st.session_state    页面的存储，防止刷新丢失数据

通过调用knowledge_base.py里面的upload_by_str函数来完成文档的上传操作。

## vector.py
实现检索工具

使用chroma里面的as_retriever检索文档，同时配置了检索几篇相关文档。

## file_chat_messages_history
实现长期对话记录保存到本地
使用了FileChatMessageHistory
定义了session_id  会话id
storage_path   会话保存路径
file_path   整合保存路径和会话id

add_messages()  实现将消息与历史消息的整合，将所有消息保存为json格式

messages()读取本地的历史消息

clear() 删除所有消息

## rag.py 
核心模块，将所有功能整合成链LCEL

vector_search  使用了vector里面定义的检错工具

template   提示词模板

llm		使用的语言模型

chain	链

用户输入 -->    检索相关文档 -->  提取历史对话消息   -->  将用户输入问题，相关文档和历史对话消息注入提示词模板当中    -->   llm模型生成回答   -->   格式化模型输出

注意：chain中使用了RunnablePassthrough 来使得用户输入在链的运行过程中不会丢失。


## app_face_to_user.py
面向用户的交互页面

同时通过session_state.messages来实现页面历史对话的功能

 
通过stream 和yeild实现流式输出

## config_data 
内含各种配置参数






